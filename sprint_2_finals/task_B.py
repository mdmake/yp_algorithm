"""
Номер посылки

-- ПРИНЦИП РАБОТЫ --

Я реализовал калькулятор выражений написанных в обратной польской нотации на стеке
Если на вход поступает операнд, он кладется в стек, если операция -- то из стека вынимается необходимое
число операндов, производится операция и результат кладется в стек.
После обработки входных данных результат находится на вершине стека.


-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Алгоритм представляет собой логику операций над структурой данных стек.
При корректности исходного выражения последний оставшийся в стеке элемент и будет результатом вычислений


-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Добаление и удаление элемента в стеке имеет временную сложность O(1).
Вычисление значение выражений c фиксированным количеством операндов так же имеет временную сложность O(1).
Итого, каждая операция стоит не более O(1), итоговая временная сложность -- O(1).


-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
В худшем случае, когда все операнды нахлдятся в начале, необходимо будет выделить под них n/2 элементов.
Каждая унарная операция не увеличивает размер стека, каждая бинарная и тернарные уменьшают размер стека.
Итого, пространственная сложность в худшем случае O(n/2) ~ O(n)
"""


import sys


class EquationSolver:
    def __init__(self):
        self.result = None
        self.stack = None
        self.operation = {
            '+': lambda x, y: x + y,
            '-': lambda x, y: x - y,
            '/': lambda x, y: x // y,
            '*': lambda x, y: x * y,
        }

    def solve(self, equationList):
        self.stack = []
        for item in equationList:
            if item.lstrip('-').isdigit():
                self.stack.append(int(item))
            else:
                b = self.stack.pop()
                a = self.stack.pop()
                self.stack.append(self.operation[item](a, b))

        self.result = self.stack.pop()
        return self.result


if __name__ == '__main__':
    equation = sys.stdin.readline().rstrip().split()
    solver = EquationSolver()
    result = solver.solve(equation)

    print(result)
