"""
Номер посылки 63252442

-- ПРИНЦИП РАБОТЫ --
Я реализовал поиск элемента в сломанном массиве за O(log n). Работы алгоритма основанна на приеме
'двух указателей', один из которых указывает на левую границу обоасти поиска, а второй на правую.
На каждом шаге вычисляется середина области поиска, и, в зависимости от того где находится искомый элемент,
сдвигается правая или левая границы.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
 Алгоритм функционирует по аналогии с обычным поиском, но с некоторыми особенностями.
 Принцип работы строится на том, что сломанный массив при делении пополам распадается на две части,
 'сломанную' и 'упорядоченную по возрастанию'. Каждый шаг алгоритма делит массив пополам, и,
 если элемент находится в упорядоченной части, запускается бинарный поиск, если в сломаной --
 то сломанная часть опять делится по полам, пока не будет достигнута ситуация, при которой искомый элемент
 находится в упорядоченной части массиваю.
 Это условие достигается в любом случае, так как массив из одного элемента является упорядоченным

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Каждый шаг алгоритма уменьшает область поиска в два раза. Временная сложность - O(log n)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Массив содержит n элементов. Дополнительная память не используется, пространственная сложность O(n).

P.S. У меня есть красивое решение с рекурсией, но оно не проходт по времени.
Это так и задумано, или я неправильно ее применял?)
"""

def binary_search(arr, x, left, right):
    while left <= right:
        if right <= left:
            if arr[right] == x:
                return right
            else:
                return -1

        # промежуток не пуст
        mid = (left + right) // 2
        if x <= arr[mid]:
            right = mid
        else:
            left = mid + 1


def broken_search(nums, target) -> int:
    j = len(nums) - 1
    i = 0

    while i <= j:
        mid = i + (j - i + 1) // 2

        if (nums[j] < target or target < nums[i]) and nums[i] <= nums[j]:
            return -1

        if nums[i] <= target <= nums[j]:
            return binary_search(nums, target, i, j)

        if nums[i] <= target:
            if nums[i] <= nums[mid] < target:
                i = mid
                continue
            else:
                j = mid - 1
                continue

        if target <= nums[j]:
            if target < nums[mid] <= nums[j]:
                j = mid - 1
                continue

            else:
                i = mid
                continue
    return -1
