"""
Номер посылки 63282987

-- ПРИНЦИП РАБОТЫ --
Я реализовал поиск элемента в сломанном массиве за O(log n). Работы алгоритма основанна на приеме
'двух указателей', один из которых указывает на левую границу обоасти поиска, а второй на правую.
На каждом шаге вычисляется середина области поиска, и, в зависимости от того где находится искомый элемент,
сдвигается правая или левая границы.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
 Алгоритм функционирует по аналогии с обычным поиском, но с некоторыми особенностями.
 Принцип работы строится на том, что сломанный массив при делении пополам распадается на две части,
 'сломанную' и 'упорядоченную по возрастанию'. Каждый шаг алгоритма делит массив пополам, и,
 если элемент находится в упорядоченной части, запускается бинарный поиск, если в сломаной --
 то сломанная часть опять делится по полам, пока не будет достигнута ситуация, при которой искомый элемент
 находится в упорядоченной части массиваю.
 Это условие достигается в любом случае, так как массив из одного элемента является упорядоченным

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Каждый шаг алгоритма уменьшает область поиска в два раза. Временная сложность - O(log n)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Массив содержит n элементов. Дополнительная память не используется, пространственная сложность O(1).

P.S. У меня есть красивое решение с рекурсией, но оно не проходт по времени.
Это так и задумано, или я неправильно ее применял?)
"""

from typing import List


def broken_search(nums: List[int], target: int) -> int:
    j = len(nums) - 1
    i = 0

    while i <= j:
        mid = i + (j - i) // 2

        if nums[mid] == target:
            return mid

        # левая половина отсортированна
        if nums[i] <= nums[mid]:
            if nums[i] <= target <= nums[mid]:
                j = mid - 1
            else:
                i = mid + 1
        # правая половина отсортированна
        else:
            if nums[mid] <= target <= nums[j]:
                i = mid + 1
            else:
                j = mid - 1

    return -1
